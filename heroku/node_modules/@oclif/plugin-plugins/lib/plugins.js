"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Config = require("@oclif/config");
const errors_1 = require("@oclif/errors");
const cli_ux_1 = require("cli-ux");
const fs = require("fs");
const loadJSON = require("load-json-file");
const path = require("path");
const semver = require("semver");
const util_1 = require("./util");
const yarn_1 = require("./yarn");
const initPJSON = { private: true, oclif: { schema: 1, plugins: [] }, dependencies: {} };
class Plugins {
    constructor(config) {
        this.config = config;
        this.yarn = new yarn_1.default({ config, cwd: this.config.dataDir });
        this.debug = require('debug')('@oclif/plugins');
    }
    async pjson() {
        try {
            const pjson = await loadJSON(this.pjsonPath);
            return Object.assign({}, initPJSON, { oclif: Object.assign({}, initPJSON.oclif, pjson.oclif), dependencies: {} }, pjson);
        }
        catch (err) {
            this.debug(err);
            if (err.code !== 'ENOENT')
                process.emitWarning(err);
            return initPJSON;
        }
    }
    async list() {
        const pjson = await this.pjson();
        return this.normalizePlugins(pjson.oclif.plugins);
    }
    async install(name, tag = 'latest') {
        try {
            const range = semver.validRange(tag);
            const unfriendly = this.unfriendlyName(name);
            if (unfriendly && await this.npmHasPackage(unfriendly)) {
                name = unfriendly;
            }
            await this.createPJSON();
            await this.yarn.exec(['add', `${name}@${tag}`]);
            const plugin = await Config.load({ devPlugins: false, userPlugins: false, root: path.join(this.config.dataDir, 'node_modules', name), name });
            if (!plugin.valid && !this.config.plugins.find(p => p.name === '@oclif/plugin-legacy')) {
                throw new Error('plugin is invalid');
            }
            await this.add({ name, tag: range || tag, type: 'user' });
        }
        catch (err) {
            await this.uninstall(name).catch(err => this.debug(err));
            throw err;
        }
    }
    async link(p) {
        const c = await Config.load(path.resolve(p));
        if (!c.valid && !this.config.plugins.find(p => p.name === '@oclif/plugin-legacy')) {
            throw new errors_1.CLIError('plugin is not a valid oclif plugin');
        }
        await this.add({ type: 'link', name: c.name, root: c.root });
    }
    async add(plugin) {
        const pjson = await this.pjson();
        pjson.oclif.plugins = util_1.uniq([...pjson.oclif.plugins || [], plugin]);
        await this.savePJSON(pjson);
    }
    async remove(name) {
        const pjson = await this.pjson();
        if (pjson.dependencies)
            delete pjson.dependencies[name];
        pjson.oclif.plugins = this.normalizePlugins(pjson.oclif.plugins)
            .filter(p => p.name !== name);
        await this.savePJSON(pjson);
    }
    async uninstall(name) {
        try {
            const pjson = await this.pjson();
            if ((pjson.oclif.plugins || []).find(p => typeof p === 'object' && p.type === 'user' && p.name === name)) {
                await this.yarn.exec(['remove', name]);
            }
        }
        finally {
            await this.remove(name);
        }
    }
    async update() {
        const plugins = await this.list();
        if (plugins.length === 0)
            return;
        cli_ux_1.default.action.start(`${this.config.name}: Updating plugins`);
        await this.yarn.exec(['add', ...plugins
                .filter((p) => p.type === 'user')
                .map(p => `${p.name}@${p.tag}`)
        ]);
        cli_ux_1.default.action.stop();
    }
    async hasPlugin(name) {
        const list = await this.list();
        return list.find(p => this.friendlyName(p.name) === this.friendlyName(name));
    }
    async yarnNodeVersion() {
        try {
            let f = await loadJSON(path.join(this.config.dataDir, 'node_modules', '.yarn-integrity'));
            return f.nodeVersion;
        }
        catch (err) {
            if (err.code !== 'ENOENT')
                cli_ux_1.default.warn(err);
        }
    }
    unfriendlyName(name) {
        if (name.includes('@'))
            return;
        const scope = this.config.pjson.oclif.scope;
        if (!scope)
            return;
        return `@${scope}/plugin-${name}`;
    }
    friendlyName(name) {
        const scope = this.config.pjson.oclif.scope;
        if (!scope)
            return name;
        const match = name.match(`@${scope}/plugin-(.+)`);
        if (!match)
            return name;
        return match[1];
    }
    // private async loadPlugin(plugin: Config.PJSON.PluginTypes) {
    //   return Config.load({...plugin as any, root: this.config.dataDir})
    // }
    async createPJSON() {
        if (!fs.existsSync(this.pjsonPath)) {
            await this.savePJSON(initPJSON);
        }
    }
    get pjsonPath() {
        return path.join(this.config.dataDir, 'package.json');
    }
    async npmHasPackage(name) {
        try {
            const http = require('http-call').HTTP;
            let url = `${this.config.npmRegistry}/-/package/${name.replace('/', '%2f')}/dist-tags`;
            await http.get(url);
            return true;
        }
        catch (err) {
            this.debug(err);
            return false;
        }
    }
    async savePJSON(pjson) {
        pjson.oclif.plugins = this.normalizePlugins(pjson.oclif.plugins);
        const fs = require('fs-extra');
        await fs.outputJSON(this.pjsonPath, pjson, { spaces: 2 });
    }
    normalizePlugins(input) {
        let plugins = (input || []).map(p => {
            if (typeof p === 'string') {
                return { name: p, type: 'user', tag: 'latest' };
            }
            else
                return p;
        });
        plugins = util_1.uniqWith(plugins, (a, b) => a.name === b.name || (a.type === 'link' && b.type === 'link' && a.root === b.root));
        return plugins;
    }
}
exports.default = Plugins;
